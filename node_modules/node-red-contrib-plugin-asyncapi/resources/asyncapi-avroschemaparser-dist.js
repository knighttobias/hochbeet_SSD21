(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
var AsyncAPIAvro = window.AsyncAPIAvro || {};
AsyncAPIAvro.Parser = require('@asyncapi/avro-schema-parser');
window.AsyncAPIAvro = AsyncAPIAvro;

},{"@asyncapi/avro-schema-parser":2}],2:[function(require,module,exports){
const { avroToJsonSchema } = require('./to-json-schema.js');

module.exports.parse = async ({ message, defaultSchemaFormat }) => {
  const transformed = await avroToJsonSchema(message.payload);

  message['x-parser-original-schema-format'] = message.schemaFormat || defaultSchemaFormat;
  message['x-parser-original-payload'] = message.payload;
  message.payload = transformed;
  delete message.schemaFormat;
};

module.exports.getMimeTypes = () => {
  return [
    'application/vnd.apache.avro;version=1.9.0',
    'application/vnd.apache.avro+json;version=1.9.0',
    'application/vnd.apache.avro+yaml;version=1.9.0',
    'application/vnd.apache.avro;version=1.8.2',
    'application/vnd.apache.avro+json;version=1.8.2',
    'application/vnd.apache.avro+yaml;version=1.8.2'
  ];
};

},{"./to-json-schema.js":3}],3:[function(require,module,exports){
const BYTES_PATTERN = '^[\u0000-\u00ff]*$';
const INT_MIN = Math.pow(-2, 31);
const INT_MAX = Math.pow(2, 31) - 1;
const LONG_MIN = Math.pow(-2, 63);
const LONG_MAX = Math.pow(2, 63) - 1;

const typeMappings = {
  null: 'null',
  boolean: 'boolean',
  int: 'integer',
  long: 'integer',
  float: 'number',
  double: 'number',
  bytes: 'string',
  string: 'string',
  fixed: 'string',
  map: 'object',
  array: 'array',
  enum: 'string',
  record: 'object',
  uuid: 'string',
};

module.exports.avroToJsonSchema = async function avroToJsonSchema(avroDefinition) {
  const jsonSchema = {};
  const isUnion = Array.isArray(avroDefinition);

  if (isUnion) {
    jsonSchema.oneOf = [];
    for (const avroDef of avroDefinition) {
      const def = await avroToJsonSchema(avroDef);
      jsonSchema.oneOf.push(def);
    }

    return jsonSchema;
  }
  
  // Avro definition can be a string (e.g. "int")
  // or an object like { type: "int" }
  const type = avroDefinition.type || avroDefinition;
  jsonSchema.type = typeMappings[type];
  
  switch (type) {
  case 'int':
    jsonSchema.minimum = INT_MIN;
    jsonSchema.maximum = INT_MAX;
    break;
  case 'long':
    jsonSchema.minimum = LONG_MIN;
    jsonSchema.maximum = LONG_MAX;
    break;
  case 'bytes':
    jsonSchema.pattern = BYTES_PATTERN;
    break;
  case 'fixed':
    jsonSchema.pattern = BYTES_PATTERN;
    jsonSchema.minLength = avroDefinition.size;
    jsonSchema.maxLength = avroDefinition.size;
    break;
  case 'map':
    jsonSchema.additionalProperties = await avroToJsonSchema(avroDefinition.values);
    break;
  case 'array':
    jsonSchema.items = await avroToJsonSchema(avroDefinition.items);
    break;
  case 'enum':
    jsonSchema.enum = avroDefinition.symbols;
    break;
  case 'record':
    const propsMap = new Map();
    for (const field of avroDefinition.fields) {
      const def = await avroToJsonSchema(field.type);
      if (field.doc) def.description = field.doc;
      if (field.default) def.default = field.default;
      propsMap.set(field.name, def);
    }
    jsonSchema.properties = Object.fromEntries(propsMap.entries());
    break;
  }

  if (avroDefinition.doc) jsonSchema.description = avroDefinition.doc;
  if (avroDefinition.default !== undefined) jsonSchema.default = avroDefinition.default;

  return jsonSchema;
};

},{}]},{},[1]);
